<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我是如何从MCU开发转到linux开发</title>
      <link href="2021/06/06/how-mcu2linux/"/>
      <url>2021/06/06/how-mcu2linux/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从大二开始玩单片机，2019年想转linux开发，但是无从下手；在工作中，终于在2020年中无缝、平滑过渡到linux上开发，想会议下自己转变之路，同时也希望后面自己进一步成长后，现在的认知是对，然后能够帮助同样迷惑小伙伴。至于linux转mcu，前两年合作的小伙伴就是纯linux出生，感觉转mcu也是需要改变固有认知，但是毕竟没有经历过，则不再展开叙述。<br><em>注： 19领证结婚，20年喜迎我的小宝贝</em></p></blockquote><h1 id="一、-曾经的迷茫"><a href="#一、-曾经的迷茫" class="headerlink" title="一、 曾经的迷茫"></a>一、 曾经的迷茫</h1><p>&emsp;&emsp;2019年的时候，就想慢慢的学linux开发，由于那时候工作才不到一年，自己本身又不是科班出生，在学校的是基本是以单片机（MCU）开发为主，所以那时候想学，但是感觉想学的有特别多。就挺迷茫的。感觉还挺像linux的那个企鹅，就无奈~~<img src="/medias/how-mcu2linux/linux.jpeg" alt="linux logo"><br>后面又做了一个<strong>协议栈评估项目</strong>，自己从<em>项目成员</em>变成了<em>技术负责人</em>，其中很多时间都投入到了项目里。虽然我是<em>技术负责人</em>，但主要是负责mcu这块的工作，由于项目目标不明确，从梳理需求到完成需求，花费了很多时间，就跟没有时间去按部就班的学linux了。记得19年，看过《linux就该这样学》，但是感觉里面都是八股文，以运维、考试为主，所以最后也不了了之；也看过《鸟哥的Linux私房菜》，不知道是语言关系还是咋地，最后也开了个头而已。但是还是得感谢<strong>协议栈评估项目</strong>，在这个项目里，作为<em>技术负责人</em>多少还是需要了解一下linux、Android和qnx，同时也熟悉git，进一步的学习计算机网络，也更加的实操了编译相关的问题，这在我后面平滑的过渡到linux奠定了很少的基础，后面也会分析到。<br>&emsp;&emsp;当初想学linux（当时不知道linux开发还细分好多）的初衷其实就是觉得对着一堆黑框框开发好炫，一个命令，咵咵出来一堆东西；然后看到其他人，啥命令都懂、都能拼出来，后面才知道原来有table自动补全、还有<code>help</code>和<code>man</code>命令；也觉得他们能从一堆<strong>黑压黒压的字母</strong>中，找到错误出现在哪里；还觉得交叉编译好神奇呀。作为技术男，怎能忍受自己不会这么牛逼的事情，所以就下定决心，自己也得会。就酝酿着要开始学linux，大概的浏览了几本书，上来就是<code>vim</code>使用、<em>必须要掌握的linux</em>，反正讲了一堆实操的东西，当时还觉得，<em>恩，这就是我想学的</em>。但是学了之后，因为自己还主要是单片机开发，一段时间后，都忘了、忘了。。。。；也看过一些其他的书籍，有从盘古开天辟地开始写的，还是前面提到的由于不是科班出生，直接给我干懵了，差点就从入门都放弃了。好在心里也一直挂念着这个事，在积累了一些计算机基础过后，觉得自己<em>能行</em>了，自己偷偷干了一些linux项目，就给领导说，linux开发喊上我，没问题的。<br>&emsp;&emsp;虽说，我觉得linux很炫，但并不意味着单片机开发就很low，感觉这更多是个人爱好和随着工作内容决定的。</p><h1 id="二、-MCU2linux"><a href="#二、-MCU2linux" class="headerlink" title="二、 MCU2linux"></a>二、 MCU2linux</h1><p>&emsp;&emsp;如果能够回到过去，开天眼，也许能够做的更好，但是自恋的说，觉得当初的做法也是挺正确（毕竟工作还是需要完成的），并没有想着一蹴而就，也没有就此放弃。在这，以我现在的认知分析一下mcu和linux的差别，以及从mcu转到linux</p><h2 id="1-mcu和linux、os"><a href="#1-mcu和linux、os" class="headerlink" title="1. mcu和linux、os"></a>1. mcu和linux、os</h2><h2 id="2-代码获取-版本管理–git"><a href="#2-代码获取-版本管理–git" class="headerlink" title="2. 代码获取/版本管理–git"></a>2. 代码获取/版本管理–git</h2><h2 id="3-编译、链接"><a href="#3-编译、链接" class="headerlink" title="3. 编译、链接"></a>3. 编译、链接</h2><h2 id="4-虚拟内存"><a href="#4-虚拟内存" class="headerlink" title="4. 虚拟内存"></a>4. 虚拟内存</h2><h2 id="5-进程-线程"><a href="#5-进程-线程" class="headerlink" title="5. 进程/线程"></a>5. 进程/线程</h2><h2 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h2><h2 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h2>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mcu </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux间网络通信无界面实时抓包、分析以及文件同步</title>
      <link href="2021/06/06/linux-develop-tips1/"/>
      <url>2021/06/06/linux-develop-tips1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这周四、五趁着工作间隙以及加班折腾了两天，实现了wireshark远程实时抓包和显示，以及两个linux之间文件同步。也许没多难，又或者有更好的办法，但是我折腾了好久，觉得可以记录下。</p></blockquote><h1 id="一、-背景"><a href="#一、-背景" class="headerlink" title="一、 背景"></a>一、 背景</h1><p>&emsp;&emsp;现在都基本都是以linux上的开发为主，然后日常开发环境在部门的两台服务器（都是ubuntu）上，但是主要还是在一台服务器上，因为我本身暂时是以网络相关的开发为主，这就避免不了的需要抓包分析，报文交互基本上能够分析出问题所在。我是远程ssh登录来做日常开发工作，如果使用tcpdump来抓包分析，一个是不是特别的直观，还有就是灵活性不是特别够，要是直接在屏幕上显示，根据不同的需求，需要一直该改命令，所以就想着能够使用远程或者本地来使用wireshark来分析报文。如下图所示，是我实际工作网络拓扑示意图，<img src="/medias/linux-develop-tips/server_and_mypc.png" alt="工作网络拓扑"></p><p>&emsp;&emsp;上面提到了主要是在一台服务器完成开发，但是有时候跑client/server时，还是要在两台电脑通过物理网络通道测试一下。这就涉及到了在两台电脑同步开发的问题，就会涉及到文件同步的问题。</p><h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>&emsp;&emsp;工欲善其事必先利其器，所以针对前面提到痛点，还是想解决点，想了不少解决思路，并且都进行了尝试，针对失败的问题进行了分析。</p><h2 id="1-网络抓包"><a href="#1-网络抓包" class="headerlink" title="1. 网络抓包"></a>1. 网络抓包</h2><p>&emsp;&emsp;针对网络抓包，分别尝试了：</p><ol><li>在我的个人工作电脑上，使用远程桌面，服务器的ubuntu上安装上linux版的wireshark，这样我就可以实时对着报文分析了。但是失败了。</li><li>将我的个人pc连接到上图中的交换机上，wireshark使用混杂模式将交换机上的所有报文都抓到，再通过过滤，过滤（显示过滤和抓包过滤）掉不必要的报文。结果失败</li><li>使用wireshark上的远程抓包。结果成功</li></ol><p>最终只有<em>方法3</em>成功了，但是却是我最后想到的，下面将稍微展开的分析下每个方法，我觉得后续有时间，都是能够成功的。</p><h3 id="1-远程桌面"><a href="#1-远程桌面" class="headerlink" title="1). 远程桌面"></a>1). 远程桌面</h3><p>&emsp;&emsp;针对远程桌面这种办法，一开始用的是VNC，其中xfor4是最能满足我的需求，因为我们的服务器上并没有外接显示器，这样就会有一个弊端，如果我将桌面输出到xfore4上去了，后面服务器即使外接了显示器也会没用，这就给别人带来不便利。咱也不能干这样<strong>损人利己</strong>的事，在简单的挣扎后（**其实不简单，尝试了好多种办法~~**），还是放弃了这样做。想要实现远程桌面的同志可以参考下这篇文章，<a href="https://blog.csdn.net/u012911347/article/details/90267252">使用RealVNC连接无外接显示器的Ubuntu18.04</a>，这篇文章还是亲测有用的。<br>&emsp;&emsp;后面又试了下，teamviewer，能够连接上，但是不显示桌面，通过查资料，基本上可以判定，是需要外接显示器的。<br>&emsp;&emsp;经过上述折腾后，果断放弃了这个方法。</p><h3 id="2-将pc直接连接到交换机上"><a href="#2-将pc直接连接到交换机上" class="headerlink" title="2). 将pc直接连接到交换机上"></a>2). 将pc直接连接到交换机上</h3><p>&emsp;&emsp;之前我调试网络时，都是自己的电脑通过网线接到交换机上，剩余其他的网络终端都连接到交换机，这样我就能从我的电脑上抓到所有的报文，简单方便、快捷，所以我这次我也想这样。正好我有两个笔记本，我可以将我的其中一个<em>笔记本电脑1</em>通过网线接入到交换机上，然后另一个<em>笔记本2</em>远程<em>笔记本1</em>，达到我的想法。如下图所示:<img src="/medias/linux-develop-tips/doublepc.png" alt="双电脑方案"><br>然而理想很丰满，现实很残酷，部门小组里的交换机虽然跟我以前一样是个二层交换机，但是上图的<strong>my_pc1</strong>并没有能够抓到server1和server2的网络报文，搜过官网，找过淘宝，聊过京东，依然没有找到答案。后面还以为wireshark没开<em>混杂模式</em>，最后发现也不是这个原因。没有解决这个问题，总觉心里有根刺，后面找交换机资料时，才得到答案，现在的交换机变聪明了，如果不是发给你的报文，mac就给你过滤掉了，并且这个交换机还不支持配置成混杂模式。欲哭无泪~~~。<br>&emsp;&emsp;曾经沧海难为水，经历过以前交换机的便利，咋能容忍这种拉低工作效率的存在。果断买网线买交互机，后面直接从我的电脑网口怼到交换机上。</p><h3 id="3-wireshark远程抓包"><a href="#3-wireshark远程抓包" class="headerlink" title="3). wireshark远程抓包"></a>3). wireshark远程抓包</h3><p>&emsp;&emsp;虽然经历上面两个方法的失败，但是心里还是挂念着，最终于在使用wireshark捕获时，突然看到有一个<strong>远程接口</strong>，技术敏感告诉我，问题应该得到解决了，一阵baidu/google后，终于成功的远程抓到了两个服务器的网络报文了。如下图所示：<img src="/medias/linux-develop-tips/win_wireshark_rpcap.png" alt="windows wireshark远程抓包"><br>想要达到上述效果，首先需要在windows wireshark上在管理接口/远程接口上添加远程设备，如下图所示：<img src="/medias/linux-develop-tips/win_wireshark_r_if.png" alt="远程接口"><br>想要实现windows 环境下wireshark远程抓包，需要在服务器端linux上另外安装rpcap来做server（tcpdump相关的自然是需要的）。<br>关于安装rpcap，直接参考<a href="https://github.com/rpcapd-linux/rpcapd-linux">github仓库上的教程</a>即可,如下图所示：<img src="/medias/linux-develop-tips/rpcap_install.png" alt="rpcap build and use">。<br>针对使用，其实也蛮简单的，<code>sudo ./rpcapd -4 -n -p [your port] -deamon</code>，端口的就是自己自定义的，后面在wireshark上需要输入，比如我我设置的是<em>55555</em>，如下图所示。另外最好将<em>rpcapd</em>设置成开机自启动了，因为万一服务器重启了，你还要手动开启<em>rpcapd</em>，岂不是很low。<img src="/medias/linux-develop-tips/linux_rpcap.png" alt="linux rpcap配置"></p><p>&emsp;&emsp;由于windows电脑略有反应迟钝，主要是以mac为主，想着还是用mac端的wireshark也实现远程抓包，发现mac上的wireshark没有<strong>远程接口</strong>这个东西了（我的是m1 macbookpro）。但是一顿摸索后，发现有这个<strong>SSH remote capture: sshdump</strong>，如下图所示，意思也很明显了，剩下就交给baidu/google了。<img src="/medias/linux-develop-tips/mac_wireshark.png" alt="mac wireshark"><br>但是一顿操作下来，发现不是报这个错<img src="/medias/linux-develop-tips/mac_wireshark_cannotfind.png" alt="can&#39;t find .."><br>就是报权限不够的错误，类似下图这个错误：<img src="/medias/linux-develop-tips/mac_wireshark_permission.png" alt="permission invalid"><br>由于任务紧张，只能暂且搁置折腾了，等后面在试试了咯。暂时先用windows实时抓包用着了呗。</p><h2 id="2-文件同步"><a href="#2-文件同步" class="headerlink" title="2. 文件同步"></a>2. 文件同步</h2><p>&emsp;&emsp;文件同步，我们用的比较多的有系统（windows、mac os）自带的局域网同步，或者onedriver这样的云同步。但是在linux上我只想针对某些文件进行网络同步即可，用onedriver除了有可能违反公司安全规定外，未免也太大材小用了，所以就考虑其他方案。</p><ol><li>通过git。需要不停的<code>add, commit, push, pull</code>，太繁琐，<strong>pass</strong>。</li><li>scp，会出现全部拷贝，不能增量拷贝，多了之后，效率特别低，对磁盘也是频繁读写，<strong>pass</strong>。</li><li>rsync_inotify，实时、增量同步，<strong>amazing</strong>。如下图：<img src="/medias/linux-develop-tips/rsync_inotify.png"></li></ol><p><strong>文件同步</strong><br>&emsp;&emsp;针对这个方案，我主要参考了这篇文章<a href="https://www.cnblogs.com/qinhir/p/6589403.html">实现rsync+inotify 实时同步文件</a>，但是对着这篇文章，我没有成功，再结合这篇文章<a href="http://blog.chinaunix.net/uid-13954085-id-158637.html">把rsync错误报告说清楚</a>,就基本把问题解决了，当然过程还是挺不容易的，因为都是网上搜索+自己摸索的，暂时也就不去记录了，如果小伙伴有疑问，可以在评论区留言，基本能够保证短时间内收到评论。<br>&emsp;&emsp;最终我没用inotify来实时同步，但是亲测是可行的，因为我怕其他同事也要同步，会影响他们，不过我通过设置命令行别名的方式<code>alias sync_xxxx=&#39;xxxxx&#39;</code>,就能一个命令同步过去了。如下图所示，我能在意位置直接就<code>rsync_BWG</code>就能将我事先配置的文件同步过去。<img src="/medias/linux-develop-tips/alias_rsync.png" alt="alias rsync"></p><p><strong>同步时忽略某些文件或者文件夹</strong><br>&emsp;&emsp;在同步时，有时我们并不需要将所有文件同步过去。<img src="/medias/linux-develop-tips/bgw_tree_l1.png" alt="BGW"> <img src="/medias/linux-develop-tips/uds_component_tree_l1.png" alt="uds-component"><br>上述俩图，<code>ironman-imx8-buildroot</code>和<code>.vscode</code>我就不想同步过去，此时我就可以通过<code>--exclude</code>这个option来达到目的，<strong>文件是使用相对路径哦</strong>。示例如下图：<img src="/medias/linux-develop-tips/use_exclude.png" alt="use --exclude"></p><h1 id="三、写在最后"><a href="#三、写在最后" class="headerlink" title="三、写在最后"></a>三、写在最后</h1><p>&emsp;&emsp;虽然说工欲善其事必先利其器，但是关键的是还需要平衡利弊，如果改进一点效率反而会浪费你更多的时间，我觉得反而是得不偿失的。不过，要是利用自己玩手机刷剧的时间，用来去折腾这个技术，我觉得是值当的，因为表面是折腾这一项，拔出萝卜带出泥，遇到问题了，想解决，基本上会涉及到很多知识面，针对我这种还需大量学习的人说，简直是成长的<em>兴奋剂</em>。以前玩单片机时，就各种折腾windows系统；后面因为linux上有很多可以折腾的，所以我就转到了linux开发，有兴趣可以参考下<a href="https://jinbaotang.cn/2021/06/06/how-mcu2linux/">我是如何从MCU开发转到linux开发</a>，不过当前（2021.06.07 02:13）未完成。</p><p>&emsp;&emsp;针对上面有些地方不够详细，可以评论区留言~~</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> wireshark </tag>
            
            <tag> rsync </tag>
            
            <tag> pcap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于openssl实现tls+socket的安全通信-2</title>
      <link href="2021/06/06/tls-socket2/"/>
      <url>2021/06/06/tls-socket2/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://jinbaotang.cn/2021/05/05/tls-socket/">接基于openssl实现tls+socket的安全通信-1</a>,这篇还要是讲解生成秘钥、证书，并且是使用<em>socket api</em>和<em>openssl api</em>来实现基于tls的安全通信。由于证书链并没有新东西，该篇主要还是以单证书为例，后续可以再整一个基于证书链的通信。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 协议栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
            <tag> tls </tag>
            
            <tag> openssl </tag>
            
            <tag> ethernet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码重构-1</title>
      <link href="2021/06/05/refactor-1/"/>
      <url>2021/06/05/refactor-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录第一次稍大规模的重构。这是我第三次写DoIP, 第1.5次写UDS，第一次写CANTP、router。</p></blockquote><h1 id="一、-背景"><a href="#一、-背景" class="headerlink" title="一、 背景"></a>一、 背景</h1><p>&emsp;&emsp;在<a href="https://jinbaotang.cn/2021/04/11/why-write/">为什么要写博客</a>里提到了，由于个人关系，换工作了。新工作的首要任务就是优化已有代码，在花了一段时间阅读代码整体框架后，发现已有的代码框架层次不太清楚，如果要优化的话，总感觉是在做错误的事。进而跟领导提出重构的想法，领导也赞同。就开始<strong>浴火重生</strong>之路了，跟之前的工作背景相关，重构了就想做成可迭代、跨平台的，所以在过去的一两个月不是就是在设计就是在验证了，这段时间，无论是在车上、洗澡还是睡觉前都是在脑子里跑流程，也真正的体会到了<em>面向对象</em>（虽然我是用c）带来的好处了。也终于一点点的体会到了，原来之前老虞（<strong>技术偶像之一</strong>）看着规范写代码也没有这么的神奇，<em>注：离老虞的水平当然还有很远的路，梦想还是要有的嘛，莫欺少年穷。</em>—记于2021.06.05 <img src="/medias/refactor-1/dream.jpeg"></p><h2 id="1-关于面向对象"><a href="#1-关于面向对象" class="headerlink" title="1. 关于面向对象"></a>1. 关于面向对象</h2><p>&emsp;&emsp;自己目前是主<strong>c</strong>，暂时略懂一点c++，有一段时间一直挺想进一步学c++的，虽然自己工作之余也写过一个webserver的小程序，但是暂时受限工作内容，也谈不上能够熟练使用c++了。之前想学c++的原因也比较单纯，很多人都说c是面向过程的语言，c++是面向对象的语言，而面向对象是人正常的思维方式。所以觉得必须得学会c++，无论是为了做知识储备，还是为了学会面向对象的思维方式。可是后面学了一段时间的c++后，其实还是不知道面向对象和面向对象有什么区别，直到有一天看<strong>vsomeip</strong>的源码（并不是第一次看），突然就<strong>顿悟了</strong>，很神奇的一件事。<em>无论任何事，即使遇到了很大的困难，我都相信这些困难和问题会在某一个时间点解决</em>，这是在困境中，一直激励着自己的话。<br>&emsp;&emsp;关于面向对象和面向过程，网上有铺天盖地的解释，比如：<a href="https://www.zhihu.com/question/27468564/answer/226691160">如何通俗易懂地举例说明「面向对象」和「面向过程」有什么区别？</a>。但是我还是想谈谈自己的理解。我觉上面链接说的我挺认可的一句话就是：<strong>首先是命名冲突，英文单词也就那么几个，可能写着写着取名时就没合适的短词用了，为了避免冲突，只能把函数名取得越来越长。</strong>当然这不是面向对象就能解决的，因为比如C语言，由于没有命名空间的概念，有些函数不想弄成<strong>static</strong>，以为有其他的文件可能会用到这个函数，这就到导致了，你的整个工程/动态库都只能有这个一个函数名了；还有就是类型了，用c/c++难免会自己构造一些自己的类型，还是像函数一样，由于了没有像<strong>命名空间</strong>这样作用域的限制，在一个程序里如果有同样的命名，即使不会带来编译、链接出错，也会给代码可读性带来灾难。但是另一方面，如果有了面向对象的思想后，就会自动的对一些数据结构打包（struct）在一起，这就像一个类了，再添加几个函数指针就像是<em>弱化版虚函数</em>，打包的在一起后，也会不自觉地对一些变量和函数添加<strong>static</strong>来修饰了，这样限制了作用域，提高了代码可读性；也减少了上面提到的命名冲突。当然对于稍大规模，又有相近概念的在一个程序里是，上面问题依然会存在，比如我曾经写过的<strong>someip</strong>代码，即使我已经划分了好几个模块，但是由于上面相近概念的太多了，也有点命名词穷，去看<strong>vsomeip</strong>代码（c++）时，就发现里面很多都是一样的名字，但是由于作用域的问题，既不会带来冲突，也不会给可读性带来问题。<br>&emsp;&emsp;上面分析了这么多，介绍了面向对象带来的好处，那到底什么是面向对象呢？有什么区别呢？<a href="https://www.zhihu.com/question/27468564/answer/101951302">编程发展史谈面向对象</a>这位答主讲的我觉得特别适合没咋写过代码，又有一定个概念的人；<a href="https://www.zhihu.com/question/27468564/answer/757537214">力扣官方解答</a>的，早我写了大概2万行两场代码后，看到的，觉得就特别适合一直主要用面向过程写c的人，图文并茂的将面向过程相对面向过程的好处讲解的很清楚。但是我觉得都不够抽象，我自己有一天吃芒果，结合自己一开始提到的<strong>顿悟</strong>，感觉可以更形象的说明<em>面向过程</em>和<em>面向对象</em>的区别：<br>如果我要吃一个芒果，面向过程就是：</p><ol><li>找到芒果</li><li>洗芒果</li><li>给芒果扒皮/切盘</li><li>吃芒果</li><li>消化芒果</li><li>我们就完成了吃掉芒果的任务<br>上面就跟流水线一下，过程化，只有做完了上一步才能下一步，不做完上一步，都不知道下一步要干啥。可能会说，我知道啊，我知道我吃一个芒果，要找、洗、切、吃、消化，对啊，这就是面向对象啊，符合人的思维方式。<br>还是以芒果为例，那面向对象：</li><li>首先就要有一个最终对象，芒果</li><li>为了吃芒果，我需要用水洗，用手扒皮，用刀切，用嘴吃，自己消化，所以还需要<em>水对象</em>，<em>手对象</em>，<em>刀对象</em>，<em>嘴对象</em>，<em>消化对象</em>。</li><li>准备完这些对象，设置对应属性，用什么水，什么刀，谁的手扒皮，谁的嘴负责最后的吃，芒果是由哪些器官消化。 </li><li>这些都用弄好，就分别一次使用对应的对选完成对应的过程，这就完成了对应吃芒果这个事了。<br>转成代码就是：</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> refactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket-can基础知识和使用</title>
      <link href="2021/05/07/socket-can/"/>
      <url>2021/05/07/socket-can/</url>
      
        <content type="html"><![CDATA[<blockquote><p>第一次接触socket can, 学习和使用的过程，也记录下来，加深印象。</p></blockquote><h1 id="一、-原理"><a href="#一、-原理" class="headerlink" title="一、 原理"></a>一、 原理</h1><p>&emsp;&emsp;虽然作为程序员最希望看到的技术文章就是直接上来甩出demo code，最好直接搬到对应的环境直接执行脚本就能跑起来，再不济也是有cmake，Makefile啥的。不管三七二十一，先跑起来再说，然后再深入学习，效率是最高的。但是这篇文章对我来说是个学习记录，还是得从原理上开始记录，后面整理时再调整顺序咯。</p><h2 id="1-can总线原理"><a href="#1-can总线原理" class="headerlink" title="1. can总线原理"></a>1. can总线原理</h2><p>&emsp;&emsp;socket can涉及到CAN总线协议、套接字、Linux网络设备驱动等。</p>]]></content>
      
      
      <categories>
          
          <category> 协议栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
            <tag> can </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于openssl实现tls+socket的安全通信-1</title>
      <link href="2021/05/05/tls-socket/"/>
      <url>2021/05/05/tls-socket/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录基于openssl来实现tls的安全通信，借助BSD socket接口来实现。也做tls简单的科普，看这篇文章，默认读者已经会socket编程了。</p></blockquote><blockquote><p>周五朋友圈突然看到前东家，也写了一篇关于tls的简单科普，突然想起我也有一个半成品文章关于tls的。这段时间由于工作繁忙，不是在refactor就是在baidu/google，不过还是蛮有意思的，等重构完成，想好好的总结一下,在<a href="https://jinbaotang.cn/2021/06/05/tls-socket/">代码重构-1</a>会这次重构带来的一些个人的进步，以及还待改进的地方。</p></blockquote><h1 id="一、-背景"><a href="#一、-背景" class="headerlink" title="一、 背景"></a>一、 背景</h1><p>&emsp;&emsp;由于业务需要，得使用tls来完成安全通信，需求也是借助开源的openssl来实现。整了好几天，才实现openssl+socket来进行安全通信。目前是证书都已经生成，但是server获取client证书出错。</p><p>&emsp;&emsp;其中在生成证书的过程中，也走了不少弯路，网上没有找到一篇介绍关于加密通信、证书原理以及使用openssl讲的比较全的文章，特别是基于C/C++ socket的就更少了，所以就萌生了自己在尝试的过程中，记录一下自己的解决轨迹。</p><h1 id="二、关于tls"><a href="#二、关于tls" class="headerlink" title="二、关于tls"></a>二、关于tls</h1><h2 id="1-tls的介绍"><a href="#1-tls的介绍" class="headerlink" title="1. tls的介绍"></a>1. tls的介绍</h2><p>&emsp;&emsp;tls是transport layer security的缩写，顾名思义就是安全传输层协议。关于tls的介绍网上有特别多了，开头也提到了，前东家发表一篇关于<a href="https://mp.weixin.qq.com/s/AnqZkYdk8XQZVT4MRidIEA">tls的文章</a>，觉得是少有的这么短篇幅介绍这么详细、生动的了。关于tls的作用主要是在解决网络安全的几个问题：</p><ol><li>保密(message privacy)，保密通过加密encryption实现，所有信息都加密传输，第三方无法嗅探；</li><li>完整性(message integrity)，通过MAC校验机制，一旦被篡改，通信双方会立刻发现；</li><li>认证(mutual authentication)，双方认证,双方都可以配备证书，防止身份被冒充；<br>对我们写的代码的来说，其实关于这些协议具体是怎么实现的，<em>暂时</em>我们并不是很关心，因为已经很多实现好的库可以使用，比如这篇文章要介绍的<a href="https://www.openssl.org/">openssl</a>。甚至对于https以上的开发者，都不关心tls的使用。但是对于需要使用基于tcpip接口（<em>eg：BSD socket接口</em>），还需要关心一些tls库的使用的。</li></ol><p>&emsp;&emsp;虽然我们可以暂时不关心tls协议的实现，但是对于tls关于密码学部分，觉得了解了原理后，能够正确、更好的使用tls库的接口，前面提到<a href="https://mp.weixin.qq.com/s/AnqZkYdk8XQZVT4MRidIEA">tls的文章</a>对于简单的原理来说，讲的真的蛮不错了，但是对于证书那一块，我觉得可以再展开一下。所以借花献佛了，在上面的文章基础，着重对证书那部分展开讲</p><h2 id="2-tls加密技术"><a href="#2-tls加密技术" class="headerlink" title="2. tls加密技术"></a>2. tls加密技术</h2><p>&emsp;&emsp;tls依赖于两种加密技术：</p><ol><li>对称加密（symmetric encryption）</li><li>非对称加密（asymmetric encryption）</li></ol><h3 id="1-字母缩写"><a href="#1-字母缩写" class="headerlink" title="1). 字母缩写"></a>1). 字母缩写</h3><blockquote><p>K: Key<br>E: Encrypt<br>D: Derypt<br>M: Message<br>C: Certificate</p></blockquote><h3 id="2-对称加密"><a href="#2-对称加密" class="headerlink" title="2). 对称加密"></a>2). 对称加密</h3><p>&emsp;&emsp;关于对称加密是最好理解的，在小唐和小潘手里都有一份秘钥K（比如所有字都是按照一点规则转成数字+1），小唐给小潘发悄悄话之前会用秘钥K加密悄悄话，小潘接收到小唐的悄悄话，小潘是知道规则，先减1，再转成数字，诶，发现是小唐对小潘的情话，那出于双方的交流需要，当然需要响应了。所以小潘也按照之前的方法加密了一下，然后发给了小唐。即：</p><pre class="line-numbers language-none"><code class="language-none">小唐: C &#x3D; E(M, k)小潘: M &#x3D; D(C, K)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-非对称加密"><a href="#3-非对称加密" class="headerlink" title="3). 非对称加密"></a>3). 非对称加密</h3><p>&emsp;&emsp;上面提到小唐和小潘都有一套一样的加密规则，非对称加密呢，就是两个人手上的加密规则是不一样的，比如小唐的是K1(数字+1), 小潘的是K2(数字乘以3)。虽然规则不一样，但是都能互相解密对方的信息，拿到对方真正想要表示的信息。即：</p><pre class="line-numbers language-none"><code class="language-none">小唐: C &#x3D; E(M, k)小潘: M &#x3D; D(C, K)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-数字签名和CA"><a href="#4-数字签名和CA" class="headerlink" title="4). 数字签名和CA"></a>4). 数字签名和CA</h3><p>&emsp;&emsp;在前面提到了秘钥K，消息发送给对方之前会进行加密，然后接收方收到消息后解密。但是想想秘钥怎么发送过去呢，明文发送过去不就被人偷听、篡改，比如<a href="https://mp.weixin.qq.com/s/AnqZkYdk8XQZVT4MRidIEA">tls的文章</a>提到的梁山伯与祝英台。</p><p>为了成全有情人，大佬发明了**数字签名（digital signature)**技术。数字签名的做法是：</p><ol><li>小唐把自己的公钥和ID（比如他身份证号或者生辰八字）一起组成一个<strong>证书签名请求（certificate signing request，CSR）</strong>，</li><li>小唐把<strong>CSR</strong>发给一个德高望重、大家都认可的人<strong>证书管理中心（ certificate authority，CA）</strong>，比如月老，</li><li>月老用自己的私钥加密小唐的<strong>CSR</strong>，得到的密文被称为<strong>数字签名（digital signature）</strong>，</li><li>月老把 <strong>数字签名</strong> 和 <strong>CSR</strong> 的明文合在一起称为<strong>月老签署的身份证（CA signed certificate，CRT</strong>），发给小唐，</li></ol><pre class="line-numbers language-none"><code class="language-none">小唐: CSR &#x3D; 小唐公钥+小唐身份证     数字签名 &#x3D; E(CSR, 月老的私钥)     CRT &#x3D; CSR + 数字签名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;每当其他人（比如小潘）找小唐聊天(eg:htts)的时候，小唐出示自己的月老签署的身份证<strong>（CRT.CSR)<strong>。拿到这个身份证的人，只要他是相信月老的(在自己机器上安装了月老的身份证</strong>CRT</strong>)，就可以:</p><ol><li>从月老的身份证中的月老的<strong>CSR</strong>里提取月老的公钥；</li><li>用月老的公钥解密小唐的身份证中月老的<strong>数字签名</strong>，得到一个小唐的**CSR’**；</li><li>如果这个<strong>CSR’<strong>和小唐身份证中的</strong>CSR</strong>明文一致，则说明<strong>”这个小唐的身份证是月老确认过并且签名的”</strong>。</li><li>小潘只要相信月老，就相信这个身份证，就相信小唐</li></ol><pre class="line-numbers language-none"><code class="language-none">小潘：月老的公钥 &#x3D; 月老的CRT.CSR.月老的公钥     CSR&#39; &#x3D; D(小唐的CRT.数字签名, 月老的公钥)     if CSR&#39; &#x3D;&#x3D;小唐的CRT.CSR then OK     I belive 小唐<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;由此过程可以看出来：随便谁都可以当<strong>CA（月老)<strong>——只要愿意公开自己的公钥，即可用自己的私钥去加密别人的认证。那我们要是信错了</strong>CA</strong>，被他摆一道怎么办，比如祝母也想当<strong>CA* *<strong>？答案是：</strong>没办法</strong>。我们必须选择信任社会，要相信如果<strong>CA</strong>说谎，万一被识破，就没有人再相信他了，所谓的<strong>CA</strong>即失去公信力。现实中，很多操作系统（Windows、Mac OS X）和浏览器（Chrome、 Firefox、IE）会内置一些靠谱的 CA 的身份证。但是有没有<strong>CA</strong>冒天下之大不韪说谎呢？从知乎上看到了<a href="https://www.zhihu.com/question/49291684/answer/123313224">CNNIC</a>的机构好像就是一个我们信错的那个人。</p><p>&emsp;&emsp;这个过程可以用下图描述：<img src="/medias/tls-socket/tang_pan.png" alt="小唐和小潘对话"></p><p>&emsp;&emsp;当然，这只是一个示意图，因为大部分聊天都需要双输入账号，上面也加上了账号和密码，但是并不准确的表示协议的握手和通信过程。 图中省略了一些重要的细节，比如握手之后的实际通信都是采用对称加密技术来实现的，因为保证双方获取的公钥是没有被篡改和获取的，使用对称加密能够提到加解密速度。因为TLS模式下所有传输的数据都是加密的，大家会关注加密和解密的性能。客 观的说，非对称加密技术的加密和解密比较慢，相对来说，对称加密技术的加密 解密过程更快。所以实际的连接和握手过程中，通信双方会协商一个对称加密秘 钥，之后的数据通信过程中的加密都是利用对称加密技术来实现的。</p><p>&emsp;&emsp;具体的做法是：握手的时候，双方各自生成一个随机数，并且以非对称加密的方式 分享给对方。然后每一方都把自己的随机数和对方的随机数拼起来，就是接下来 通信时候使用的对称加密方法的秘钥了。</p><h3 id="5-信任链"><a href="#5-信任链" class="headerlink" title="5). 信任链"></a>5). 信任链</h3><p>&emsp;&emsp;月老如果担心没有人信任自己是个好<strong>CA</strong>（就像没人信CNNIC一样），可以找一个大家都信的<strong>CA</strong>（CNNIC改成了DigiCert签发的证书），比如民政局，用民政局的私钥在月老的身份证上签名：</p><pre class="line-numbers language-none"><code class="language-none">月老：CSR &#x3D; 月老的公钥+月老身份证     数字签名 &#x3D; E(CSR, 民政局的私钥)     CRT &#x3D; CSR + 数字签名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;如果浏览器或者操作系统里安装了民政局的公钥则可以验证<strong>“月老的身份证是民政局确认并且签名过的”</strong>，信月老就不再是迷信了，就算是官方认证过的了。</p><p>&emsp;&emsp;这样，月老在签署小唐的身份证的时候，可以在小唐身份证后面附上自己的身份证。这样小唐的身份证就有<strong>“两页”</strong>了。</p><p>&emsp;&emsp;当小潘和小唐通信的时候：</p><ol><li>小潘会先要求小唐出示自己的身份证；</li><li>小潘虽然不信任月老，但是信任民政局，所以小潘可以用民政局的身份证里的月老的公钥来验证小唐身份证附带的月老的身份证，于是就可以信任月老了；</li><li>小潘用月老身份证里的公钥验证小唐的身份证。<br>要是怕 小潘连自己也也不信任，民政局可以再找一个 小潘信任的人来签名确认自己的身份证。这个过程可以不断递推，从而形成了一条**信任链（trust of chain)**。</li></ol><h3 id="6-根身份证和自签名"><a href="#6-根身份证和自签名" class="headerlink" title="6).根身份证和自签名"></a>6).根身份证和自签名</h3><p>&emsp;&emsp;信任链总会有个顶端，被称为根身份证（root CA）。那么根身份证是谁签名的呢？答案是：<strong>自己签名</strong>。实际上，我们每个人都可以自己签名认证自己的身份证，得到<strong>自签名的身份证（self-signed certificate）</strong>。具体过程是：</p><ol><li>生成一对秘钥：公钥 K2 和私钥 K1，</li><li>创建自己的 <strong>CSR</strong>，</li><li>用自己的秘钥加密<strong>CSR</strong>得到<strong>数字签名</strong>，然后把<strong>CSR</strong>明文和<strong>数字签名</strong>一起发布。</li></ol><p>任何人只要信任我们自签名的身份证 <strong>CRT</strong>，也就可以用 <strong>CRT.CSR.K2</strong>作为公钥加密要传递给我们的文本。我们可以用自己的私钥K1来解密文本。</p><p>如果民政局就是根CA了，那么上述各位的身份证的信任链如下：</p><pre class="line-numbers language-none"><code class="language-none">小唐：CSR &#x3D; 小唐公钥+小唐域名     数字签名 &#x3D; E(CSR, 月老的私钥)     CRT &#x3D; CSR + 数字签名月老：CSR &#x3D; 月老的公钥+月老域名     数字签名 &#x3D; E(月老的CSR, 民政局的私钥)     CRT &#x3D; 月老的CSR + 数字签名民政局：CSR &#x3D; 民政局的公钥+民政局的域名      数字签名 &#x3D; E(民政局的CSR, 民政局自己的私钥)      CRT &#x3D; 民政局的CSR + 数字签名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-双方认证"><a href="#7-双方认证" class="headerlink" title="7). 双方认证"></a>7). 双方认证</h3><p>&emsp;&emsp;上述例子解释了通信的一方如何验证另一方的身份。比如车载协议DoIP-2019即是要求server验证client即可，以提高通信效率。这种情况的还有一个常见应用是： 我们通过浏览器访问银行的网页。这里的关键是，我们要能验证银行的身份证， 然后才敢于在网页里输入账号和密码。浏览器验证银行的身份证的过程如下：</p><ol><li>在浏览器和银行的HTTPS服务建立安全连接的过程中，银行的HTTPS服务会把 它的身份证发给浏览器showcerts；</li><li>浏览器使用内置的CA的身份证来验证银行的身份证。</li></ol><p>浏览器验证了银行的HTTPS服务的身份之后，就轮到银行验证浏览器的用户的身份了：</p><ol><li>浏览器展示银行HTTPS服务发来的登陆页面；</li><li>用户在这个页面里输入账号和密码，银行的HTTPS服务由此验证用户的身份。<br>在这个过程中，银行HTTPS服务器的身份是通过TLS身份证来验证的。而我们（用户）的身份是通过我们输入的账号和密码来验证的。</li></ol><p>&emsp;&emsp;有时通信的双方都是程序（而不是人）。此时，让一方输入账号和密码，不如让 双方都通过TLS身份证来互相验证方便。尤其是在很多分布式系统里，有多种类型的程序互相通信，而不只是两方通信。<br>&emsp;&emsp;比如在Kubernetes机群里，不光操作机群的客户端程序kubectl要能验证 Kubernetes master node（具体的说是apiserver的身份，才能放心地把包括 敏感信息（比如数据库密码）的计算作业提交给apiserver。类似的，apiserver也要能验证kubectl的身份，以确认提交作业的是公司的合法雇员，而不是外贼sign。<br>&emsp;&emsp;为此，通信各方都需要有各自的身份证。一个公司可以自签名一个CA身份证，并且用它来给每个雇员以及每个程序签署身份证。这样，只要每台电脑上都预先安装好公司自己的CA身份证，就可以用这个身份证验证每个雇员和程序的身份了。这是目前很多公司的常用做法。</p><h2 id="3-tls协议实现"><a href="#3-tls协议实现" class="headerlink" title="3. tls协议实现"></a>3. tls协议实现</h2><p>&emsp;&emsp;由于tls在安全方面的重要作用，应用特别广泛，相对来说就会有不少开源实现，比较知名就有openssl和mbed-tls，分别应用在通用操作系统和基于mcu的嵌入式系统了。这里要介绍的即是在通用操作系统（linux），对openssl的应用了。</p><h1 id="三、关于openssl"><a href="#三、关于openssl" class="headerlink" title="三、关于openssl"></a>三、关于openssl</h1><p>&emsp;&emsp;上面介绍了tls的基本原理，对我们程序员来说最重要的就是coding了，那我们就看看如何在linux上使用openssl来实现基于tcpip的安全通信。</p><h2 id="1-openssl安装和使用"><a href="#1-openssl安装和使用" class="headerlink" title="1. openssl安装和使用"></a>1. openssl安装和使用</h2><p>&emsp;&emsp;在安装是和使用之前，先简单的介绍一下openssl，openssl是一个安全套接字层密码库，囊括主要的密码算法、常用密钥、证书封装管理功能及实现ssl协议。openssl整个软件包大概可以分成三个主要的功能部分：SSL协议库libssl、应用程序命令工具以及密码算法库libcrypto。<br>&emsp;&emsp;安装之前，直接先<code>openssl version -a</code>看下是否有安装openssl，我日常使用的是ubuntu16和ubuntu18，如下图是已经安装好的。<img src="/medias/tls-socket/openssl_v.png" alt="openssl-version">如果没有，建议直接去<a href="https://www.openssl.org/source/">openssl的官网</a>或者<a href="https://github.com/openssl/openssl">openssl git仓库</a>下载安装，本来还想写下要如何下载、编译安装，后面觉得实在多次一举了。个人建议还是直接在官网或者git仓库查看教程了，git仓库上直接有各个平台的安装教程]了。<img src="/medias/tls-socket/install_course.png" alt="各个平台的安装教程"></p><p><em>注：ubuntu直接<code>sudo apt-get install openssl</code>和<code>sudo apt-get insall libssl-dev</code>即可</em>，其他平台估计也有直接安装的。</p><p>&emsp;&emsp;关于openssl在linux的一些命令并不打算自己去写，可以参考这篇文<a href="https://segmentfault.com/a/1190000014963014">openssl的介绍和使用</a>,后面会降到如何在linux上会使用openssl来生成秘钥和证书，以及证书管理工具。文章<a href="https://segmentfault.com/a/1190000014963014">openssl的介绍和使用</a>介绍命令并不是特别全，但是给出了一个命令具体的含义，很多教程上来就直接生成秘钥证书，像我这种之前从来没有接触过这块东西的人，还是挺懵逼的，但是看到了这这篇文章后，对着其他教程，跌跌撞撞还是跑通了一个demo。上面虽然写的不全，但是也写了可以通过<code>-help</code>来获取更详细的命令参数含义，比如openssl genrsa -help就会将所有的参数显示出来。<img src="/medias/tls-socket/openssl_genrsa_help.png" alt="openssl genrsa -help">。后面再搜到不同的教程，<code>-help</code>一下，从此不再迷茫。</p><p>&emsp;&emsp;对于openssl接口的一些文章，我主要参考了这篇<a href="https://www.cnblogs.com/Yogile/p/12917402.html">基于OpenSSL的简单C/S通信C程序设计使用函数文档</a>和<a href="https://www.openssl.org/docs/man1.0.2/man3/">官方英文文档</a>，当然有时候嫌烦，就直接baidu/google对应函数了。</p><h2 id="2-openssl实操"><a href="#2-openssl实操" class="headerlink" title="2. openssl实操"></a>2. openssl实操</h2><p>&emsp;&emsp;上一小节，除了安装、编译适合在实操之前操作，其他部分更多是在实操过程中去搜索的。当然由于我已经有过相关的实操经验了，对于想使用openssl来完成安全通信的小伙伴，记住上述相关介绍和链接，再结合后面的示例，应该能够达到事半功倍的效果。在tls握手过程之前，需要tcp三次握手后建立tcp连接，而后才开始tls1的握手。tls的握手过程如下图所示，图随便找的，侵删：<img src="/medias/tls-socket/tls_handshake.png" alt="tls handshake"><br>虚线部分为可选的，可选的原因是因为，一般都是server验证client的单向验证，比如前面的提到的DoIP-2019；但是如果需要双向认证，即是client验证server，前面也有提到应用场景，具体步骤如下：</p><ul><li><p>步骤 1. ClientHello – 客户端发送所支持的 SSL/TLS 最高协议版本号和所支持的加密算法集合及压缩方法集合等信息给服务器端。</p></li><li><p>步骤 2. ServerHello – 服务器端收到客户端信息后，选定双方都能够支持的 SSL/TLS 协议版本和加密方法及压缩方法，返回给客户端。</p></li><li><p>（可选）步骤 3. SendCertificate – 服务器端发送服务端证书给客户端。</p></li><li><p>（可选）步骤 4. RequestCertificate – 如果选择双向验证，服务器端向客户端请求客户端证书。</p></li><li><p>步骤 5. ServerHelloDone – 服务器端通知客户端初始协商结束。</p></li><li><p>（可选）步骤 6. ResponseCertificate – 如果选择双向验证，客户端向服务器端发送客户端证书。</p></li><li><p>步骤 7. ClientKeyExchange – 客户端使用服务器端的公钥，对客户端公钥和密钥种子进行加密，再发送给服务器端。</p></li><li><p>（可选）步骤 8. CertificateVerify – 如果选择双向验证，客户端用本地私钥生成数字签名，并发送给服务器端，让其通过收到的客户端公钥进行身份验证。</p></li><li><p>步骤 9. CreateSecretKey – 通讯双方基于密钥种子等信息生成通讯密钥。</p></li><li><p>步骤 10. ChangeCipherSpec – 客户端通知服务器端已将通讯方式切换到加密模式。</p></li><li><p>步骤 11. Finished – 客户端做好加密通讯的准备。</p></li><li><p>步骤 12. ChangeCipherSpec – 服务器端通知客户端已将通讯方式切换到加密模式。</p></li><li><p>步骤 13. Finished – 服务器做好加密通讯的准备。</p></li><li><p>步骤 14. Encrypted/DecryptedData – 双方使用客户端密钥，通过对称加密算法对通讯内容进行加密，进行数据通信。</p></li><li><p>步骤 15. ClosedConnection – 通讯结束后，任何一方发出断开 SSL 连接的消息。</p></li></ul><p>SSL握手主要完成以下任务：</p><ol><li> 协商使用的加密套件。加密套件中包括一组加密参数，这些参数指定了加密算法和密钥的长度等信息。</li><li>验证对方的身份，此操作是可选的。</li><li>确定使用的加密算法。</li><li>SSL握手过程采用非对称加密方法传递数据，由此来建立一个安全的SSL会话。SSL握手完成后，通信双方将采用对称加密方法传递实际的应用数据。</li></ol><p>最简单、应用广泛的应用场景即是server验证client了.</p><h3 id="1-秘钥、证书等生成"><a href="#1-秘钥、证书等生成" class="headerlink" title="1). 秘钥、证书等生成"></a>1). 秘钥、证书等生成</h3><p><strong>暂时没有时间展开细讲，可以参考<a href="https://github.com/jinbaotang/tls_test">我的git仓库–tls_test</a></strong>,这块东西涉及的还是蛮多，感觉可以另开一个话题了，如果不在这篇文章继续，就可以参考链接<a href="https://jinbaotang.cn/2021/06/06/tls-socket2/">基于openssl实现tls+socket的安全通信-2</a>,</p>]]></content>
      
      
      <categories>
          
          <category> 协议栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
            <tag> tls </tag>
            
            <tag> openssl </tag>
            
            <tag> ethernet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LwIP使用select，close socket资源释放不完全问题</title>
      <link href="2021/04/12/lwip-close-socket-select/"/>
      <url>2021/04/12/lwip-close-socket-select/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章本应该在4月就写好的，但是博客评论系统一直没有搭建好，走了很多弯路，现在好了，delay这么久，终于要要补过来了。</p></blockquote><blockquote><p>该文章完全原创，除通用、广泛的知识点外，均为个人总结，如需转载还望备注出处，同时如有错误还请指出，虚心接受。</p></blockquote><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-题外话"><a href="#1-题外话" class="headerlink" title="1. 题外话"></a>1. 题外话</h2><p>&emsp;&emsp;以这篇文章为第一篇技术文章，一是萌生写博客的契机是换工作，另外就是这篇文章是我在怿星解决的最后一个bug。</p><p><img src="/medias/lwip-close-socket-select/jinbao-ept.jpg"></p><p>&emsp;&emsp;问题来源是，跑在基于LwIP+FreeRTOS环境的DoIP，在反复初始化/反初始化时几次之后就会失败了。年初由于任务紧张，检查了下初始化和反初始化函数的流程，改掉了几处可能会出现问题的地方，问题依旧。但是同样的上层处理代码，在windows和linux环境下是没问题的，基本怀疑是LwIP某处不完善引起。一直拖到要离职，终于在离开的最后一天解决了，也算是给在怿星的DoIP协议栈画上一个属于自己的句号。</p><p>&emsp;&emsp; LwIP 全名为 Light weight IP，意思是轻量化的 TCP/IP 协议， 是瑞典计算机科学院(SICS)的 Adam Dunkels 开发的一个小型开源的 TCP/IP 协议栈。 LwIP 的设计初衷是：用少量的资源消耗(RAM)实现一个较为完整的 TCP/IP 协议栈，其中“完整”主要指的是 TCP 协议的完整性， 实现的重点是在保持 TCP 协议主要功能的基础上减少对 RAM 的占用。此外 LwIP既可以移植到操作系统上运行，也可以在无操作系统的情况下独立运行。</p><h2 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h2><p>&emsp;&emsp;引起该问题的根本原因是，LwIP select函数里如果判断对应的socket没有事件产生（读/写/异常），进行简单处理后则改线程休眠，让出cpu控制权。如果在select休眠期间，进行了close socket的操作，会释放对应的socket pcb（<strong>close(socket)<strong>是成功的），然后在select休眠结束后，判断该socket资源不存在，则直接退出select函数，</strong>但是</strong>此时该socket的select_wait标志位没被清除。LwIP在分配socket时（资源都是静态分配的，类似于有一个socket数组，若分配则对应标志位为真），socket是否空闲是会对select_wait该标志位进行判断，所以即使该socket没有被使用，调用*socket()*函数时也会认为该socket是被占用的，所以几次之后，socket资源被<strong>假耗尽</strong>。</p><h2 id="3-解决"><a href="#3-解决" class="headerlink" title="3. 解决"></a>3. 解决</h2><p>&emsp;&emsp;知道原因后，问题就好解决了。有以下两个解决问题的思路。</p><ol><li>更改LwIP源码，对对应的标志位进行判断和清除。该解决方案，如果能够push到LwIP主分支，则是一劳永逸的，否则如果要跟随LwIP官方更新，自己得维护一套代码，并持续merge。</li><li>使用者，在使用接口时，做同步。即在select休眠期间不允许进行close socket操作，同时在close socket也不允许进入select函数。所以只要在两个函数之间加上条件判断就好。</li></ol><p>&emsp;&emsp;考虑到维护成本，最终选择方案2.</p><h1 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h1><p>&emsp;&emsp;解决思路在上面已经给出，下面主要想从源码级对问题进行分析。原因中，涉及三个函数，</p><ol><li><p>socket函数，即lwip_socket，函数原型如下：<br><code>int lwip_socket(int domain, int type, int protocol)</code></p></li><li><p>close函数，即lwip_close，原型如下：<br><code>int lwip_close(int s)</code></p></li><li><p>select函数， 即lwip_select(),原型如下：<br><code>intlwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout)</code></p></li></ol><h2 id="1-拓展"><a href="#1-拓展" class="headerlink" title="1. 拓展"></a>1. 拓展</h2><p>&emsp;&emsp;LwIP本身提供了类似于bsd socket编程模型，同时也实现了简易版的select函数。</p><p>&emsp;&emsp;关于socket编程的教程是实在太多了，在这不再重复去描述，<a href="https://blog.csdn.net/weixin_39634961/article/details/80236161">socket编程参考链接</a>。辅导过一些人进行socket编程，初学者包括我自己，容易忽略的一点就是，作为server时，listen-socket和accept-socket不是一回事。可以理解为listen-socket窗口，窗口只是负责监听有谁要走通道，走哪个通道，并把真正的通道–accept-socket给到上层。对于其他的，感觉跑跑示例程序，单步走一下，就基本理解了。</p><p>&emsp;&emsp;在不使用select时，并没有发现socket资源释放不完全的问题。本文不展开讲解lwip select的实现，但是对于select的使用需要稍微展开下，<a href="https://www.cnblogs.com/skyfsm/p/7079458.html">select编程参考链接</a>。关于select本质上是一个同步I/O函数，只不过改同步函数可以同时监控多个”IO”通道，所以也称为多路复用。熟悉了上面的socket编程后，如果需要实现多个socket同时通信的话，就应该给每个socket开一个线程，在负载不是特别高的情况下会显得效率特别低，同时线程太多，就不得不考虑资源竞争的问题，如果竞态条件太多，也容易产生问题（<strong>多线程资源竞争问题</strong>）。多路复用即是用一个线程监听多个通道（描述符），一旦某个描述符就绪（可读、可写或者异常），就通知程序进行相应的读写操作。上庙的描述，看起来select是异步的，其实不然，因为产生读写事件后，应用程序必须自己负责读写操作，读写操作本身是阻塞的，而异步I/O是不需要自己读写；同时即使没有读写事件产生，select函数本身也是阻塞的，加了超时也是阻塞的，只不过给阻塞增加了一个时间限制。</p><p>&emsp;&emsp;select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。从<a href="https://www.cnblogs.com/skyfsm/p/7079458.html">select编程参考链接</a>中可以看出最终每个socket都对应到每个bit上，如果对应的socket有事件产生，则会被置位。</p><h2 id="2-函数分析"><a href="#2-函数分析" class="headerlink" title="2. 函数分析"></a>2. 函数分析</h2><p>&emsp;&emsp;该节分析函数socket，close，select实现细节。<strong>LwIP版本2.1.4</strong>。</p><h3 id="2-1-socket函数"><a href="#2-1-socket函数" class="headerlink" title="2.1 socket函数"></a>2.1 socket函数</h3><p>&emsp;&emsp;lwip中<code>#define socket lwip_socket</code>.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">lwip_socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">netconn</span> <span class="token operator">*</span>conn<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token function">LWIP_UNUSED_ARG</span><span class="token punctuation">(</span>domain<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* @todo: check this */</span>    <span class="token comment">/* create a netconn */</span>    <span class="token comment">/* 下面主要是针对不同的socket类型，分配空间，对相应的成员进行赋值，空间资源为预分配给lwip的堆空间     */</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> SOCK_RAW<span class="token operator">:</span>        conn <span class="token operator">=</span> <span class="token function">netconn_new_with_proto_and_callback</span><span class="token punctuation">(</span>            <span class="token function">DOMAIN_TO_NETCONN_TYPE</span><span class="token punctuation">(</span>domain<span class="token punctuation">,</span> NETCONN_RAW<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">u8_t</span><span class="token punctuation">)</span>protocol<span class="token punctuation">,</span>            event_callback<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">LWIP_DEBUGF</span><span class="token punctuation">(</span>SOCKETS_DEBUG<span class="token punctuation">,</span>                    <span class="token punctuation">(</span><span class="token string">"lwip_socket(%s, SOCK_RAW, %d) = "</span><span class="token punctuation">,</span>                     domain <span class="token operator">==</span> PF_INET <span class="token operator">?</span> <span class="token string">"PF_INET"</span> <span class="token operator">:</span> <span class="token string">"UNKNOWN"</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> SOCK_DGRAM<span class="token operator">:</span>        conn <span class="token operator">=</span> <span class="token function">netconn_new_with_callback</span><span class="token punctuation">(</span>            <span class="token function">DOMAIN_TO_NETCONN_TYPE</span><span class="token punctuation">(</span>domain<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>protocol <span class="token operator">==</span> IPPROTO_UDPLITE<span class="token punctuation">)</span>                                                <span class="token operator">?</span> NETCONN_UDPLITE                                                <span class="token operator">:</span> NETCONN_UDP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            event_callback<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">LWIP_DEBUGF</span><span class="token punctuation">(</span>SOCKETS_DEBUG<span class="token punctuation">,</span>                    <span class="token punctuation">(</span><span class="token string">"lwip_socket(%s, SOCK_DGRAM, %d) = "</span><span class="token punctuation">,</span>                     domain <span class="token operator">==</span> PF_INET <span class="token operator">?</span> <span class="token string">"PF_INET"</span> <span class="token operator">:</span> <span class="token string">"UNKNOWN"</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> SOCK_STREAM<span class="token operator">:</span>        conn <span class="token operator">=</span> <span class="token function">netconn_new_with_callback</span><span class="token punctuation">(</span>            <span class="token function">DOMAIN_TO_NETCONN_TYPE</span><span class="token punctuation">(</span>domain<span class="token punctuation">,</span> NETCONN_TCP<span class="token punctuation">)</span><span class="token punctuation">,</span> event_callback<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">LWIP_DEBUGF</span><span class="token punctuation">(</span>SOCKETS_DEBUG<span class="token punctuation">,</span>                    <span class="token punctuation">(</span><span class="token string">"lwip_socket(%s, SOCK_STREAM, %d) = "</span><span class="token punctuation">,</span>                     domain <span class="token operator">==</span> PF_INET <span class="token operator">?</span> <span class="token string">"PF_INET"</span> <span class="token operator">:</span> <span class="token string">"UNKNOWN"</span><span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token function">LWIP_DEBUGF</span><span class="token punctuation">(</span>SOCKETS_DEBUG<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"lwip_socket(%d, %d/UNKNOWN, %d) = -1\n"</span><span class="token punctuation">,</span>                                    domain<span class="token punctuation">,</span> type<span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">set_errno</span><span class="token punctuation">(</span>EINVAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>conn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">LWIP_DEBUGF</span><span class="token punctuation">(</span>SOCKETS_DEBUG<span class="token punctuation">,</span>                    <span class="token punctuation">(</span><span class="token string">"-1 / ENOBUFS (could not create netconn)\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">set_errno</span><span class="token punctuation">(</span>ENOBUFS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*     *上面已经分配好了，对应的connection空间，最终要对应的socket上，即socket数组，见下面alloc_socket实现。     */</span>    i <span class="token operator">=</span> <span class="token function">alloc_socket</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">netconn_delete</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">set_errno</span><span class="token punctuation">(</span>ENFILE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    conn<span class="token operator">-></span>socket <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token function">LWIP_DEBUGF</span><span class="token punctuation">(</span>SOCKETS_DEBUG<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_errno</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">alloc_socket</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">netconn</span> <span class="token operator">*</span>newconn<span class="token punctuation">,</span> <span class="token keyword">int</span> accepted<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token function">SYS_ARCH_DECL_PROTECT</span><span class="token punctuation">(</span>lev<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* allocate a new socket identifier */</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_SOCKETS<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* Protect socket array */</span>    <span class="token function">SYS_ARCH_PROTECT</span><span class="token punctuation">(</span>lev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sockets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>conn <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sockets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>select_waiting <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      sockets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>conn       <span class="token operator">=</span> newconn<span class="token punctuation">;</span>      <span class="token comment">/* The socket is not yet known to anyone, so no need to protect         after having marked it as used. */</span>      <span class="token function">SYS_ARCH_UNPROTECT</span><span class="token punctuation">(</span>lev<span class="token punctuation">)</span><span class="token punctuation">;</span>      sockets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lastdata   <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      sockets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lastoffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      sockets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rcvevent   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">/* TCP sendbuf is empty, but the socket is not yet writable until connected       * (unless it has been created by accept()). */</span>      sockets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sendevent  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">NETCONNTYPE_GROUP</span><span class="token punctuation">(</span>newconn<span class="token operator">-></span>type<span class="token punctuation">)</span> <span class="token operator">==</span> NETCONN_TCP <span class="token operator">?</span> <span class="token punctuation">(</span>accepted <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      sockets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>errevent   <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      sockets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>err        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> i <span class="token operator">+</span> LWIP_SOCKET_OFFSET<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">SYS_ARCH_UNPROTECT</span><span class="token punctuation">(</span>lev<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;可以看到，判断socket资源是否有人在使用时，除了判断socket-&gt;conn是否为空，还会判断select_waiting是否等于0。其中select_waiting标识该socket正在被多少个线程在使用。即要释放socket资源（说释放有点不是很准确，因为在lwip中，socket资源是编译前分配的），两个重要条件是，socket-&gt;conn必须为空，并且select_waiting要为0.</p><h3 id="2-2-close函数"><a href="#2-2-close函数" class="headerlink" title="2.2 close函数"></a>2.2 close函数</h3><p>&emsp;&emsp;接下来看看close函数的实现，看为啥会导致资源释放不完全。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">lwip_close</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">lwip_sock</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>  <span class="token keyword">int</span> is_tcp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token class-name">err_t</span> err<span class="token punctuation">;</span>  <span class="token function">LWIP_DEBUGF</span><span class="token punctuation">(</span>SOCKETS_DEBUG<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"lwip_close(%d)\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 本质上是，通过socket数组下标获取到socket结构体 */</span>  sock <span class="token operator">=</span> <span class="token function">get_socket</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sock<span class="token operator">-></span>conn <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    is_tcp <span class="token operator">=</span> <span class="token function">NETCONNTYPE_GROUP</span><span class="token punctuation">(</span><span class="token function">netconn_type</span><span class="token punctuation">(</span>sock<span class="token operator">-></span>conn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> NETCONN_TCP<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">LWIP_ASSERT</span><span class="token punctuation">(</span><span class="token string">"sock->lastdata == NULL"</span><span class="token punctuation">,</span> sock<span class="token operator">-></span>lastdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_IGMP</span></span>  <span class="token comment">/* drop all possibly joined IGMP memberships */</span>  <span class="token function">lwip_socket_drop_registered_memberships</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LWIP_IGMP */</span></span><span class="token comment">/* 释放从lwip内存堆里分配到空间 */</span>  err <span class="token operator">=</span> <span class="token function">netconn_delete</span><span class="token punctuation">(</span>sock<span class="token operator">-></span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token operator">!=</span> ERR_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">sock_set_errno</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> <span class="token function">err_to_errno</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token comment">/* 主要是对socket结构体成员进行反初始化，并对数据空间进行释放，看下述对该函数实现分析 */</span>  <span class="token function">free_socket</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> is_tcp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">set_errno</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">free_socket</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">lwip_sock</span> <span class="token operator">*</span>sock<span class="token punctuation">,</span> <span class="token keyword">int</span> is_tcp<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">void</span> <span class="token operator">*</span>lastdata<span class="token punctuation">;</span>  lastdata         <span class="token operator">=</span> sock<span class="token operator">-></span>lastdata<span class="token punctuation">;</span>  sock<span class="token operator">-></span>lastdata   <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  sock<span class="token operator">-></span>lastoffset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  sock<span class="token operator">-></span>err        <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">/* Protect socket array */</span>  <span class="token comment">/* 对socket->conn进行置空 */</span>  <span class="token function">SYS_ARCH_SET</span><span class="token punctuation">(</span>sock<span class="token operator">-></span>conn<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* don't use 'sock' after this line, as another task might have allocated it */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lastdata <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>is_tcp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">pbuf_free</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pbuf</span> <span class="token operator">*</span><span class="token punctuation">)</span>lastdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token function">netbuf_delete</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">netbuf</span> <span class="token operator">*</span><span class="token punctuation">)</span>lastdata<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;上述两个函数分析可知，<code>close</code>函数只能使socket-&gt;conn为空，并不能使select_waiting为0，所以其实只有<code>close</code>函数是不能使socket资源完全释放的。</p><h3 id="2-3-select函数"><a href="#2-3-select函数" class="headerlink" title="2.3 select函数"></a>2.3 select函数</h3><p>&emsp;&emsp;从<em>select_waiting</em>名字中能比较容易的猜到，该变量跟select函数肯定是强相关的。全局搜索select_waiting，果然只有select函数有进行写操作。下面分析select函数，该函数较长，做必要的简化。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">lwip_select</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxfdp1<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>readset<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>writeset<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>exceptset<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token class-name">u32_t</span> waitres <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> nready<span class="token punctuation">;</span>  fd_set lreadset<span class="token punctuation">,</span> lwriteset<span class="token punctuation">,</span> lexceptset<span class="token punctuation">;</span>  <span class="token class-name">u32_t</span> msectimeout<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">lwip_select_cb</span> select_cb<span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">int</span> maxfdp2<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">LWIP_NETCONN_SEM_PER_THREAD</span></span>  <span class="token keyword">int</span> waited <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>  <span class="token comment">/* Go through each socket in each list to count number of sockets which     currently match */</span>  <span class="token comment">/*   *扫描所有socket对应的bit，如果有准备好，则直接将对应的bit置上，后面可以看出，该函数简单的赋值后就退出了，  *不涉及对select_waiting的操作。   */</span>  nready <span class="token operator">=</span> <span class="token function">lwip_selscan</span><span class="token punctuation">(</span>maxfdp1<span class="token punctuation">,</span> readset<span class="token punctuation">,</span> writeset<span class="token punctuation">,</span> exceptset<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lreadset<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lwriteset<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lexceptset<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* If we don't have any current events, then suspend if we are supposed to */</span>  <span class="token comment">/* 只有没有相应的socket准备好并且没有超时，才回置位select_waiting, 并挂起线程。 */</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nready<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout <span class="token operator">&amp;&amp;</span> timeout<span class="token operator">-></span>tv_sec <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> timeout<span class="token operator">-></span>tv_usec <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">LWIP_DEBUGF</span><span class="token punctuation">(</span>SOCKETS_DEBUG<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"lwip_select: no timeout, returning 0\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* This is OK as the local fdsets are empty and nready is zero,         or we would have returned earlier. */</span>      <span class="token keyword">goto</span> return_copy_fdsets<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 省略一堆处理，可以看到只要该socket设置了，读写异常通知，并且socket是存在的，则会将select_wainting增加1 */</span>    <span class="token comment">/* Increase select_waiting for each socket we are interested in */</span>    maxfdp2 <span class="token operator">=</span> maxfdp1<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> LWIP_SOCKET_OFFSET<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxfdp1<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readset <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> readset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>          <span class="token punctuation">(</span>writeset <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> writeset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>          <span class="token punctuation">(</span>exceptset <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> exceptset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">lwip_sock</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>        <span class="token function">SYS_ARCH_PROTECT</span><span class="token punctuation">(</span>lev<span class="token punctuation">)</span><span class="token punctuation">;</span>        sock <span class="token operator">=</span> <span class="token function">tryget_socket</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sock <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          sock<span class="token operator">-></span>select_waiting<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token function">LWIP_ASSERT</span><span class="token punctuation">(</span><span class="token string">"sock->select_waiting > 0"</span><span class="token punctuation">,</span> sock<span class="token operator">-></span>select_waiting <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token comment">/* Not a valid socket */</span>          nready <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          maxfdp2 <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token function">SYS_ARCH_UNPROTECT</span><span class="token punctuation">(</span>lev<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">SYS_ARCH_UNPROTECT</span><span class="token punctuation">(</span>lev<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nready <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/*     *执行完上述操作，还会再扫描一次是否有socket有事件产生，删除细节。    *因为上述，如果socket资源过多，会消耗不少资源，再扫描一次可以提高效率。    */</span>      <span class="token comment">/* 休眠指定时间，让出cpu控制权 */</span>      waitres <span class="token operator">=</span> <span class="token function">sys_arch_sem_wait</span><span class="token punctuation">(</span><span class="token function">SELECT_SEM_PTR</span><span class="token punctuation">(</span>select_cb<span class="token punctuation">.</span>sem<span class="token punctuation">)</span><span class="token punctuation">,</span> msectimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 休眠结束， 将对应socket->select_waiting减1 */</span>    <span class="token comment">/* Decrease select_waiting for each socket we are interested in */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> LWIP_SOCKET_OFFSET<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxfdp2<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readset <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> readset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>          <span class="token punctuation">(</span>writeset <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> writeset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>          <span class="token punctuation">(</span>exceptset <span class="token operator">&amp;&amp;</span> <span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> exceptset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">lwip_sock</span> <span class="token operator">*</span>sock<span class="token punctuation">;</span>        <span class="token function">SYS_ARCH_PROTECT</span><span class="token punctuation">(</span>lev<span class="token punctuation">)</span><span class="token punctuation">;</span>        sock <span class="token operator">=</span> <span class="token function">tryget_socket</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 减1，必须socket是还在的 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sock <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">/* for now, handle select_waiting==0... */</span>          <span class="token function">LWIP_ASSERT</span><span class="token punctuation">(</span><span class="token string">"sock->select_waiting > 0"</span><span class="token punctuation">,</span> sock<span class="token operator">-></span>select_waiting <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>sock<span class="token operator">-></span>select_waiting <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sock<span class="token operator">-></span>select_waiting<span class="token operator">--</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>          <span class="token comment">/* Not a valid socket */</span>          nready <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">SYS_ARCH_UNPROTECT</span><span class="token punctuation">(</span>lev<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">/* 删除不影响分析代码，感兴趣参考源码。 */</span>  <span class="token keyword">return</span> nready<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><center>这是这一张来自未来的select函数处理流程图</center></strong></p><p>&emsp;&emsp;参考上述代码分析，特别注意<em>socket-&gt;select_waiting</em>加1和减1的地方，可以看到，如果socket存在且的确需要监听事件，且并不是进来事件就已经产生或者已经超时，一定会加1；然后线程会有可能会进行休眠；正常情况下，休眠结束后，<em>socket-&gt;select_waiting</em>减1，离开该函数，<em>socket-&gt;select_waiting</em>恢复原值。<strong>但是</strong>，如果在线程休眠期间，恰巧在另外一个线程进行了close操作，事件就变味了。</p><p>&emsp;&emsp;如果在休眠期间进行了<code>close(socket)</code>,则通过<code>tyr_socket(socket)</code>获取不到socket结构体，则<em>socket-&gt;select_waiting</em>不会进行减1，后面执行一系列语句后，退出该函数，<em>socket-&gt;select_waiting</em>没有恢复原值，且比进来时大1。针对该函数，<em>socket-&gt;select_waiting</em>加1的次数是*&gt;=<em>减1的次数，所以如果只要在函数退出时没有恢复原值，则</em>socket-&gt;select_waiting*永远不可能再减为0了，此时socket资源就出现了<strong>假占用</strong>，该socket再也不能被其他人使用了。</p><h1 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h1><p>&emsp;&emsp;第二章已经对产生的原因进行了分析。解决问题的思路也想一开始提到的有两种，为了不改lwip源码，使用了第二种思路。下面用伪代码给出解决方案。需要使用到两个flag<code>closing_socket_flag</code>和·selecting_flag`。<br><strong>thread1</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">adaptor_closesocket</span><span class="token punctuation">(</span><span class="token keyword">int</span> socket<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">get_select_processing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">set_closesocket_processing</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>    ret <span class="token operator">=</span> <span class="token function">close</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_closescoket_processing</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>thread2</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">select_loop</span><span class="token punctuation">(</span><span class="token keyword">int</span> socket<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">get_closesocket_processing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">set_select_processing</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>    select_return <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>sockMAX <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>read_set<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>exception_set<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_select_processing</span><span class="token punctuation">(</span>false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;上面的解决方案，我认为是最为简单通用的解决方案，当然针对两个flag肯定还是需要加锁的。另外还有一种思路就是使用通知类似于condition的方法。知道了错误原因，解决方法的思路就是做同步。</p><h1 id="四、写在最后"><a href="#四、写在最后" class="headerlink" title="四、写在最后"></a>四、写在最后</h1><p>&emsp;&emsp;LwIP无疑是一个很优秀的轻量版的TCP/IP协议实现了，虽然上面的socket接口都是简化版，当时以为如果功能是支持的，在使用以为可以跟BSD的一样。因为在开发DoIP时是跨平台，上层应用代码是一样的，在windows和linux都是支持的，所以比较简单就初步定位出了问题应该是出在了LwIP协议本身，但是当时由于现象特别奇怪（略过不表），也费了一般周折才最终定位出来。一开始觉得认为这是一个bug，后面跟老虞（技术偶像）深度讨论过，觉得这也不属于LwIP本身的一个bug，感觉更像是feature实现的不够完整，但是light weight也已经足够了。同时在使用LwIP本身也学到了很多技巧，如连接符**##**的使用、在MCU上实现分配空间的解决方案。</p><p><img src="https://savannah.nongnu.org/images/Savannah.theme/floating.png"></p>]]></content>
      
      
      <categories>
          
          <category> 协议栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
            <tag> LwIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我为什么要写博客</title>
      <link href="2021/04/11/why-write/"/>
      <url>2021/04/11/why-write/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于这篇博客，想记录下自己当前写博客的原因，同时也希望记录自己当前自己的一些看法，后面持续更新。</p></blockquote><blockquote><p>记于2021.4</p></blockquote><h1 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客"></a>为什么要写博客</h1><p> &emsp;&emsp;一直挺想用文字记录记录自己的成长轨迹，第一份工作在经纬恒润时，部门要求每天都要写写tasklist，当时刚毕业，也算是逗比一个，写的文字不止是每天工作的记录，也包含自己遇到问题时自己苦恼的心情，同时也有自己在解决了问题时开心。在入职2个多月后，转正答辩，看着自己写的tasklist，感觉自己又把前两个月过了一遍似的，当时写转正ppt也蛮顺利的。后面虽然略有偷懒，但是也会“勤勤恳恳”的记录，<br> 在2019年离职前，对在恒润的职业生涯又回顾了一遍，感觉就像看到了一个从校园出来的学生是如何慢慢变为社会人的。</p><p> &emsp;&emsp;从北京到上海，从恒润到怿星，前三个月也像模像样的在每天在记录。当时处于放养状态，很多时候都是自己在学东西，写tasklist，一方面是记录自己的学习，另一方面是为了防止领导觉得我在试用期没有成果。磕磕绊绊、断断续续也写了三个月，终于在某一天就丢了。</p><p><img src="/medias/article/2.jpeg"></p><p>&emsp;&emsp;2020年年终总结，觉得没有达到的目标，考虑到在目前平台自己成长受限就想着要换个平台。找工作嘛，避免不了要更新简历，期间回忆回忆自己做过的事情，也在感慨自己的一些成长和见识。也越来越萌生，自己需要在某个地方记录记录的学习过程以及学习成果。</p><p>&emsp;&emsp;自己在2020年一年中看了很多计算机相关的书籍，但是并没有形成总结。比如自己在看《深入理解计算机系统》时，看到虚拟内存那里，突然就明白了MCU和MPU的差异性在哪里了。在阅读《操作系统导论》时，明白了原来没有完美的设计，总是会在复杂度和性能取个折中。自己本身是一名码农(<strong>还不配称为程序员</strong>），在撸代码时，老是想实现一个完美程序，但是最终往往流产，看完这本书后也算是给了我启发。从《人月神话》这本书不仅知道了软件工作量是不能简单用人月来衡量，而且也教会了我如何看待团队水平不同层次的人，也算是摆正了自己的位置。</p><p>&emsp;&emsp;上面无论精彩的或者不精彩的内容，深刻或者不深刻的瞬间，都没用文字记录下来。现在再去回想，如虚拟内存之类，很难再体会到那种突然顿悟的激动。殊不知，那是自己从MCU转到MPU(通用操作系统)很重要的一件事，扫清了自己的认知障碍。</p><p>&emsp;&emsp;趁着跳槽之际，又是博客园整顿之时，为了让自己的博客掌握在自己的手里。在清明节前后搭建出了属于的博客，也借此希望能够学些学学nodejs，同时也想在此记录自己的心情、学习的技术以及自己的心得。ps：<em>搭建博客也踏了不少坑，希望有时间整理一篇文章。</em></p><h1 id="博客写些什么"><a href="#博客写些什么" class="headerlink" title="博客写些什么"></a>博客写些什么</h1><p>&emsp;&emsp;其实目前阶段没有特别的规划去些什么。心里大概想写一些技术类的文章，并记录自己的心得体会。加深自己对技术理解，同时也希望能够帮到在技术上一样遇到问题的有缘人，或者是在心得体会上有同感的同路人。当然，自己本身是职场人，涉及工作机密的内容或者会对公司造成任何损失的内容肯定不会出现在上面。技术类的文章，计划是完整的，有demo可以直接运行，尽量把自己在学习过程中走的弯路也都列出来，权当给自己记录了。</p><p>&emsp;&emsp;阶段性的写写总结，比如季度总结或者年终总结，在后续回顾能够看到之前的自己是傻子，这就证明了自己是在成长的。</p><p>&emsp;&emsp;后面还想要写的，也会记录在博客上。</p><h1 id="博客写给谁看"><a href="#博客写给谁看" class="headerlink" title="博客写给谁看"></a>博客写给谁看</h1><p>&emsp;&emsp;写博客的很大一个原因就是希望记录自己，所以最主要的是写给自己看的。</p><p>&emsp;&emsp;因为自己本身是一个职场人，做的东西也算是较为前沿的东西；同时自己因为没有读研，工作也还不到三年，跟很多硕士毕业的同学也是同龄人。所以在工作上遇到困难的职场人能够从我这获得启示甚至答案，也希望即将踏入职场的同龄人能够交流交流心得，愿意一起成长。</p><h1 id="博客什么时候更新"><a href="#博客什么时候更新" class="headerlink" title="博客什么时候更新"></a>博客什么时候更新</h1><p>&emsp;&emsp;暂时不定更新日期，因为第一次写博客，也知道写这个玩意儿很浪费时间和经历，用玩手机的时间写博客，最后能够坚持下来，持续的更新，自己就算是成功。最后期望自己能够稳定周期的更新博客。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
